{
    "collab_server" : "",
    "contents" : "# Function Name: \tmainSeekMC, multicore version of mainSeek using mclapply\n# Description: \t\truns main for RIP or CTL bam file(s); treat multiple bams as replicate and combine them; actual RIP regions will be predicted in seekRIP outside of this function\n# Input: \t\t\tbamPath to bam files (either a single dir or the multiple file paths) \n# Output:\t\t\tGAlignments and GRanges objects representating alignment object after disambiguating multihits (if any) and predicted RIP bins (not regions yet)\n#\n# Author: Yue Li\n###############################################################################\n\nmainSeek <- function(bamFiles, reverseComplement=FALSE, genomeBuild=\"mm9\",\n\t\tuniqueHit = TRUE, assignMultihits = TRUE, strandType = NULL,\n\t\tpaired=FALSE, rerunWithDisambiguatedMultihits = TRUE, silentMain=FALSE,\n\t\tmulticore = TRUE, returnAllResults = TRUE, ...)\t\n{\t\n\tif(multicore) {\n\t\t\n\t\thasMC <- try(require(parallel))\n\t\t\n\t\tif(!hasMC) {\n\t\t\t\n\t\t\twarning(\"multicore package is unavailable; use single-core instead.\")\n\t\t\t\n\t\t\tmulticore <- FALSE\n\t\t}\n\t}\t\t\n\t\n\tstage <- 1\n\t\n\t################ Read in BAM ################\n\t# by default, return all alignments but flag multihits for\n\t# subsequent subsetByMaxPostprobOverlaps\n\t\n\tmessage(sprintf(\"\\n**%s. Process and combine alignment files\\n\", LETTERS[stage]))\n\t\n\talignGal <- combineAlignGals(bamFiles, reverseComplement=reverseComplement, genomeBuild=genomeBuild, paired=paired)\n\t\n\tif(!is.null(strandType)) {\n\t\t\n\t\tif(!strandType %in% levels(strand(alignGal))) {\n\t\t\t\t\t\t\n\t\t\twarning(sprintf(\"*** Strand type (%s) is unknown and ignored.\", strandType))\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tmessage(sprintf(\"*** Only reads from strand %s will be considered.\", strandType))\n\t\t\t\n\t\t\talignGal <- alignGal[strand(alignGal) == strandType]\n\t\t}\t\t\n\t}\n\t\n\t\n\t################ Return unique hits only ################\n\tif(uniqueHit) {\n\t\t\n\t\tif(is.logical(values(alignGal)$uniqueHit)) {\n\t\t\t\n\t\t\tmessage(\"*** Only unique hits are used to compute read count.\")\n\t\t\t\n\t\t\talignGR <- as(alignGal[values(alignGal)$uniqueHit], \"GRanges\")\n\t\t\t\n\t\t} else {\t\t\t\n\t\t\twarning(\"*** uniqueHit is TRUE but uniqueHit flag slot is not set!\\nAll alignment will be treated as unique hits;\\notherwise try run getAlignGal(..., flagMultiHits=TRUE).\")\n\t\t\t\n\t\t\talignGR <- as(alignGal, \"GRanges\")\n\t\t}\t\t\n\t} else {\n\t\t\n\t\tmessage(\"*** All reads (including multihits) are used to construct initial HMM model.\")\n\t\t\n\t\talignGR <- as(alignGal, \"GRanges\")\n\t}\n\t\n\t################ Add pseudo count ################\n\t# checking for zero alignment in some chromosome (e.g. chrM)\n\talignGR <- addPseudoAlignment(alignGR)\n\t\n\tstage <- stage + 1\n\t\n\t\n\t################ start main function to train HMM ################\n\t\n\trunViterbi <- all(values(alignGal)$uniqueHit) || !rerunWithDisambiguatedMultihits\n\t\n\tmessage(sprintf(\"\\n**%s. Run NB HMM on each chromosome\\n\", LETTERS[stage]))\n\t\n\t\n\tif(multicore) {\n\t\t\n\t\tif(silentMain) {\n\t\t\tsuppressMessages(\n\t\t\t\t\tnbhGRList <- mclapply(as.list(split(alignGR, seqnames(alignGR))),\n\t\t\t\t\t\t\tmainSeekSingleChrom, runViterbi = runViterbi, ...))\n\t\t} else {\t\t\t\n\t\t\tnbhGRList <- mclapply(as.list(split(alignGR, seqnames(alignGR))),\n\t\t\t\t\tmainSeekSingleChrom, runViterbi = runViterbi, ...)\n\t\t}\n\t\t\n\t} else {\n\t\t\n\t\tif(silentMain) {\n\t\t\tsuppressMessages(\n\t\t\t\t\tnbhGRList <- lapply(as.list(split(alignGR, seqnames(alignGR))),\n\t\t\t\t\t\t\tmainSeekSingleChrom, runViterbi = runViterbi, ...))\n\t\t} else {\t\t\t\n\t\t\tnbhGRList <- lapply(as.list(split(alignGR, seqnames(alignGR))),\n\t\t\t\t\tmainSeekSingleChrom, runViterbi = runViterbi, ...)\n\t\t}\n\t}\n\t\n\tnbhGRList <- GRangesList(nbhGRList)\t\t\n\t\n\ttmp <- gc(); rm(tmp)\n\t\n\tstage <- stage + 1\t\n\t\n\t################ Disambiguate multihit if exists ################\n\tif(!all(values(alignGal)$uniqueHit) && uniqueHit && assignMultihits) {\n\t\t\n\t\tmessage(sprintf(\"\\n**%s. Disambiguate multihits based on posterior\\n\", LETTERS[stage]))\n\t\t\n\t\talignGalFiltered <- disambiguateMultihits(alignGal, nbhGRList)\n\t\t\n\t\tstage <- stage + 1\t\t\n\t\t\n\t\tif(rerunWithDisambiguatedMultihits) {\n\t\t\t\n\t\t\tmessage(sprintf(\"\\n**%s. Re-run NB HMM with unique hits + disambiguated multihits.\\n\",\n\t\t\t\t\t\t\tLETTERS[stage]))\n\t\t\t\n\t\t\t\n\t\t\t################ Re-run HMM on augmented library ################\n\t\t\t# re-estimating HMM parameters based on augmented read library\n\t\t\talignGR <- as(alignGalFiltered, \"GRanges\")\n\t\t\t\n\t\t\t\n\t\t\t# checking for zero alignment in some chromosome (e.g. chrM)\n\t\t\talignGR <- addPseudoAlignment(alignGR)\n\t\t\t\n\t\t\t\n\t\t\t# re-estimate parameters using augmented reads corrected with\n\t\t\t# disambiguateMultihits function\n\t\t\t# enable viterbi prediction\n\t\t\t\n\t\t\tif(multicore) {\n\t\t\t\t\n\t\t\t\tif(silentMain) {\n\t\t\t\t\tsuppressMessages(\n\t\t\t\t\t\t\tnbhGRList <- mclapply(as.list(split(alignGR, seqnames(alignGR))), \n\t\t\t\t\t\t\t\t\tmainSeekSingleChrom, runViterbi = TRUE, ...))\n\t\t\t\t} else {\n\t\t\t\t\tnbhGRList <- mclapply(as.list(split(alignGR, seqnames(alignGR))), \n\t\t\t\t\t\t\tmainSeekSingleChrom, runViterbi = TRUE, ...)\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\tif(silentMain) {\n\t\t\t\t\tsuppressMessages(\n\t\t\t\t\t\t\tnbhGRList <- lapply(as.list(split(alignGR, seqnames(alignGR))), \n\t\t\t\t\t\t\t\t\tmainSeekSingleChrom, runViterbi = TRUE, ...))\n\t\t\t\t} else {\n\t\t\t\t\tnbhGRList <- lapply(as.list(split(alignGR, seqnames(alignGR))), \n\t\t\t\t\t\t\tmainSeekSingleChrom, runViterbi = TRUE, ...)\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\n\t\t\tnbhGRList <- GRangesList(nbhGRList)            \n\t\t}\t\t\n\t\t\n\t\t\n\t\toutput <- list(nbhGRList=nbhGRList, alignGal=alignGal, alignGalFiltered=alignGalFiltered)\n\t\t\n\t} else {\n\t\t\n\t\toutput <- list(nbhGRList=nbhGRList, alignGal=alignGal)\n\t}\n\t\t\n\t# assign strandType to the strand RIP regions on each chromosome\n\tif(!is.null(strandType)) output$nbhGRList <- endoapply(output$nbhGRList,\n\t\t\t\tfunction(gr, strandType){strand(gr) <- strandType; gr}, strandType)\n\t\t\t\t\t\t\t\t\t\n\t\t\n\t################ return HMM output (alignGal + alignGalFiltered) ################\n\t\n\tif(returnAllResults) return(output)\n\tif(!returnAllResults) return(output$nbhGRList)\t\t\n}\n",
    "created" : 1440348190776.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2448656646",
    "id" : "E49BE630",
    "lastKnownWriteTime" : 1401316564,
    "last_content_update" : 0,
    "path" : "~/myBiocPkg/RIPSeeker/R/mainSeek.R",
    "project_path" : "mainSeek.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}