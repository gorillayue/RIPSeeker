{
    "collab_server" : "",
    "contents" : "# nbh_em\tEstimates the parameters of a negative binomial HMM using EM.\n# \t\t\tUse: [TRANS,alpha,beta,logl,postprob,dens] =\n# \t\t\tnbh_em(count,TRANS_0,alpha_0,beta_0,NIT_MAX,TOL) where TRANS, alpha\n# \t\t\tand beta are the estimated model parameters, logl contains\n# \t\t\tthe log-likehood values for the successive iterations,\n# \t\t\tpostprob the marginal posterior probabilities at the last\n# \t\t\titeration and dens the negative binomial probabilities\n# \t\t\tcomputed also at the last iteration.\n\n# The function is adapted from the Matlab code nbh_em.m from\n# H2M/cnt Toolbox, Version 2.0\n# Olivier Capp√©, 31/12/97 - 22/08/2001\n# ENST Dpt. TSI / LTCI (CNRS URA 820), Paris\n# Further Refs.:\n# - X. L. Meng, D. B. Rubin, Maximum likelihood estimation via the\n#   ECM algorithm: A general framework, Biometrika, 80(2):267-278 (1993).\n# - J. A. Fessler, A. O. Hero, Space-alternating generalized\n#   expectation-maximization algorithm, IEEE Tr. on Signal\n#   Processing, 42(10):2664 -2677 (1994).\n\nnbh_em <- function(count, TRANS, alpha, beta, NBH_NIT_MAX=250, NBH_TOL=1e-5,\n\t\tMAXALPHA=1e7, MAXBETA=1e7)\n{\n\t# Inputs arguments\n\tstopifnot(!missing(count))\n\tstopifnot(!missing(TRANS))\n\tstopifnot(!missing(alpha))\n\tstopifnot(!missing(beta))\n\n\t\n\t# Data length\n\tTotal <- length(count)\t\n\tif(any(count < 0) || any(count != round(count))){\n\t\tstop(\"Data does not contain positive integers.\")\n\t}\n\t\n\tcount <- matrix(count, nrow=Total, 1)\n\t# Number of mixture components\n\tN <- nbh_chk(TRANS, alpha, beta)\n\talpha <- matrix(alpha, 1, N)\n\tbeta <- matrix(beta, 1, N)\n\t\n\t\n\t# Compute log(count!), the second solution is usually much faster\n\t# except if max(count) is very large\n\tcm <- max(count)\n\tif(cm > 50000){\n\t\tdnorm <- as.matrix(lgamma(count + 1))\n\t} else {\n\t\ttmp <- cumsum(rbind(0, log(as.matrix(1:max(count)))))\n\t\tdnorm <- as.matrix(tmp[count+1])\n\t}\n\t\n\t# Variables\n\tlogl <- matrix(0, ncol=NBH_NIT_MAX)\n\tdens <- matrix(0, Total, N)\n\tscale <- rbind(1, matrix(0, nrow=Total-1))\n\t# The forward and backward variables\n\tforwrd <- matrix(0, Total, N)\n\tbckwrd <- matrix(0, Total, N)\n\t\n\t\n\t# Save initial alpha and beta in case error occurs in the first EM\n\talpha0 <- alpha\n\tbeta0 <- beta\n\tTRANS0 <- TRANS\n\tpostprob0 <- matrix(1, Total, N)/N\n\tdens0 <- dens\n\tlogl0 <- logl\n\t\n\t\t\n\t# Main loop of the EM algorithm\n\tfor(nit in 1:NBH_NIT_MAX) {\n\t\t\n\t\t# 1: E-Step, compute density values\n\t\tdens <- exp( matrix(1, nrow=Total) %*% (alpha * log(beta/(1+beta)) - lgamma(alpha))\n\t\t\t\t- count %*% log(1+beta) + lgamma(count %*% matrix(1, ncol=N) + matrix(1, nrow=Total) %*% alpha)\n\t\t\t\t- dnorm %*% matrix(1, ncol=N) )\n    \n\t\t# set zero value to the minimum double to avoid -inf when applying log\n\t\t# due to large dnorm (or essential large count)\n\t\tdens <- apply(dens, 2, function(x) {x[x==0] <- .Machine$double.xmin; x})\t\t\t\t\n        \t\n\t\t\t\t\n\t\t# 2: E-Step, forward recursion and likelihood computation\n\t\t# Use a uniform a priori probability for the initial state\n\t\tforwrd[1,] <- dens[1,]/N;\n\t\t\n\t\tfor(t in 2:Total){\n\t\t\tforwrd[t,] <- (forwrd[t-1,] %*% TRANS) * dens[t,]\n\t\t\t# Systematic scaling\n\t\t\tscale[t] <- sum(forwrd[t,])\n\t\t\tforwrd[t,] <- forwrd[t,] / scale[t]\n\t\t}\n\t\t\t\t\n\t\t# Compute log-likelihood\n\t\tlogl[nit] <- log(sum(forwrd[Total,])) + sum(log(scale))\n\t\tmessage(sprintf('Iteration %d:\\t%.3f', (nit-1), logl[nit]))\n\t\t\n\t\tif(is.nan(logl[nit])) {\n\t\t\t\n\t\t\twarning(\"NaN logl data detected. Returning the previous training results\")\n\t\t\t\n\t\t\tlogl[nit] <- 0\n\t\t\t\n\t\t\tTRANS=TRANS0; alpha=alpha0; beta=beta0\n\t\t\t\n\t\t\tlogl=logl0; bckwrd=postprob0; dens=dens0\n\t\t\t\n\t\t\tbreak\n\t\t}\n\t\t\n\t\t\n\t\t# 3: E-Step, backward recursion\n\t\t# Scale the backward variable with the forward scale factors (this ensures\n\t\t# that the reestimation of the transition matrix is correct)\n\t\tbckwrd[Total,] <- matrix(1, ncol=N)\n\t\t\t\t\n\t\tfor(t in (Total-1):1) {\t\t\t\n\t\t\tbckwrd[t,] <- (bckwrd[t+1,] * dens[t+1,]) %*% t(TRANS)\n\t\t\t# Apply scaling\n\t\t\tbckwrd[t,] <- bckwrd[t,] / scale[t]\n\t\t}\n\t\t\n\t\t\n\t\t# 4: M-Step, reestimation of the transition matrix\n\t\t# Compute unnormalized transition probabilities (this is indeed still the\n\t\t# end of the E-step, which explains that TRANS appears on the right-hand\n\t\t# side below)\n\t\tTRANS <- TRANS * (t(forwrd[1:(Total-1),]) %*% (dens[2:Total,] * bckwrd[2:Total,]))\n\t\t# Normalization of the transition matrix\n\t\tTRANS <- TRANS / (apply(TRANS, 1, sum) %*% matrix(1,ncol=N))\n\t\t\t\t\t\t\t\t\n\t\t# 5: CM-Step 1, reestimation of the inverse scales beta with alpha fixed\n\t\t# Compute a posteriori probabilities (and store them in matrix\n\t\t# bckwrd to save some space)\n\t\tbckwrd <- forwrd * bckwrd\n\t\tbckwrd <- bckwrd / ( apply(bckwrd, 1, sum) %*% matrix(1,ncol=N) )\n\t\t# Reestimate shape parameters beta conditioning on alpha\n\t\teq_count <- apply(bckwrd, 2, sum)\n\t\tbeta <- alpha / ( (t(count) %*% bckwrd) / eq_count )\n\t\t\n\t\t\n\t\t# 5: CM-Step 2, reestimation of the shape parameters with beta fixed\n\t\t# Use digamma and trigamma function to perfom a Newton step on\n\t\t# the part of the intermediate quantity of EM that depends on alpha\n\t\t# Compute first derivative for all components\n\t\tgrad <- eq_count * (log(beta / (1+beta)) - digamma(alpha)) + \n\t\t\t\t\tapply(bckwrd * digamma(count %*% matrix(1,ncol=N) +\n\t\t\t\t\tmatrix(1,nrow=Total) %*% alpha), 2, sum)\n\t\t\t\t\n\t\t\t\t\t\n\t\t# And second derivative\n\t\thess <- -eq_count * trigamma(alpha) +\n    \t\t\tapply(bckwrd * trigamma(count %*% matrix(1,ncol=N) +\n    \t\t\tmatrix(1, nrow=Total) %*% alpha), 2, sum)\n\t\t# Newton step\n\t\ttmp_step <- - grad / hess\n\t\ttmp <- alpha + tmp_step\n\t\t\n\t\t\n\t\t############ Check any abnormal trained values ############\n\t\t# in case tmp becomes NA for bad initialization or insufficient data\n\t\tif(any(is.na(tmp))) {\n\t\t\t\n\t\t\twarning(sprintf(\"Updated alpha becomes NA probably %s\",\n\t\t\t\t\t\t\t\"due to bad initial alpha or insuff. data\"))\n\t\t\t\n\t\t\t\t\t\t\t\t\t\n\t\t\tTRANS=TRANS0; alpha=alpha0; beta=beta0\n\t\t\t\n\t\t\tlogl=logl0; bckwrd=postprob0; dens=dens0\n\t\t\t\n\t\t\tbreak\n\t\t}\n\t\t\n\t\t# in case tmp becomes NA for bad initialization or insufficient data\n\t\tif(any(alpha > MAXALPHA) || any(beta > MAXBETA)) {\n\t\t\t\n\t\t\twarning(sprintf(\"Updated alpha (%f) or beta (%f) becomes too large probably %s\",\n\t\t\t\t\t\t\talpha, beta, \"due to bad initial alpha or large count\"))\n\t\t\t\n\t\t\t\n\t\t\tTRANS=TRANS0; alpha=alpha0; beta=beta0\n\t\t\t\n\t\t\tlogl=logl0; bckwrd=postprob0; dens=dens0\n\t\t\n\t\t\tbreak\n\t\t}\n\t\t############ Check END ############\n\t\t\n\t\t\t\n\t\t\t\t\n\t\t\n\t\t# When performing the Newton step, one should check that the intermediate\n\t\t# quantity of EM indeed increases and that alpha does not become negative. In\n\t\t# practise this is almost never needed but the code below may help in some\n\t\t# cases (when using real bad initialization values for the parameters for\n\t\t# instance)\n\t\twhile (any(tmp <= 0)){\n\t\t\twarning(sprintf(\"Alpha (%.4f) became negative! Try smaller (10%s) Newton step ...\\n\", tmp_step,\"%\"))\n\t\t\ttmp_step <- tmp_step/10\n\t\t\ttmp <- alpha + tmp_step\n\t\t}\n\t\t\n\t\talpha <- tmp\n\t\t\n\t\t# stop iteration if improvement in logl is less than TOL (default 10^-5)\n\t\tif(nit > 1 && abs((logl[nit] - logl[nit-1])/logl[nit-1]) < NBH_TOL){\n\t\t\tlogl <- logl[1:nit]\n\t\t\tbreak\n\t\t}\n\t\t\n\t\t# backup trained values before M-step\n\t\tTRANS0 <- TRANS\n\t\talpha0 <- alpha\n\t\tbeta0 <- beta\n\t\tpostprob0 <- bckwrd\n\t\tdens0 <- dens\n\t\tlogl0 <- logl\t\t\n\t}\n\n\t# return the trained parameters as an data frame object\n\tlist(TRANS=TRANS, alpha=alpha, beta=beta, \n\t\tlogl=logl, postprob=bckwrd, dens=dens)\t\t\t\t\n}\n",
    "created" : 1460468265312.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "780479686",
    "id" : "2FA7E745",
    "lastKnownWriteTime" : 1401316564,
    "last_content_update" : 1401316564,
    "path" : "~/myBiocPkg/RIPSeeker/R/nbh_em.R",
    "project_path" : "nbh_em.R",
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}