{
    "collab_server" : "",
    "contents" : "# Function Name: \tmainSeekSingleChrom\n# Description: \t\tx\n# Input: \t\t\ty\n# Output:\t\t\tz\n#\n# Author: Yue Li\n###############################################################################\n\nmainSeekSingleChrom <- function(alignGR, K=2, binSize = NULL, minReadCount = 10, backupNumBins=10,\n\t\tminBinSize = 200, maxBinSize = 1200, increment=5, pathToSavePlotsOfBinSizesVersusCosts, \n\t\tverbose = TRUE, allowSecondAttempt = TRUE, ...)\n{\t\n\tstopifnot(!missing(alignGR))\n\t\n\ttmp <- gc(); rm(tmp);\n\t\n\tuseDefinedBinSize <- !is.null(binSize)\n\t\t\t\t\t\t\t\n\tchrname <- as.character(runValue(seqnames(alignGR)))\n\t\n\tmessage(sprintf(\"\\n**********\\n%s:\\n**********\\n\",chrname))\n\t\n\tif(!is.null(binSize) && \n\t\t\t(!is.numeric(unlist(binSize)) || any(unlist(binSize) < 0) || \n\t\t\t\tany(unlist(binSize) != round(unlist(binSize))))\n\t) {\t\t\n\t\t\tmessage(print(binSize))\n\t\t\tstop(\"binSize is/are not positive integers.\")\t\t\n\t}\n\t\t\n\t\n\t# check whether binSize is a list/vector that contain specific\n\t# bin sizes for individual chromosomes.\n\t# Such binSize list/vector *must* has chromosome names the same \n\t# as the seqnames in alignGR\n\tif(!is.null(binSize) && length(binSize) > 1) {\n\t\t\t\t\t\t\n\t\tif(is.list(binSize)) {\n\t\t\ttmp <- binSize[[chrname]]\n\t\t} else {\n\t\t\ttmp <- binSize[chrname]\n\t\t}\n\t\t\n\t\tif(is.null(tmp) || !is.numeric(tmp) || tmp >= seqlengths(alignGR)[chrname]) {\n\t\t\t\n\t\t\twarning(\"Invalid bin size stored in the metadata of GRanges object\")\t\t\t\t\n\t\t}\t\t\t\t\n\t\t\n\t\tbinSize <- tmp\n\t\t\n\t\tmessage(sprintf(\"***0. Using predefined binSize of %d bp.\", binSize))\n\t\t\n\t} else {\n\t\tmessage(sprintf(\"***0. Using predefined binSize of %d bp.\", binSize))\n\t}\n\t\t\t\t\t\n\t# pseudoreads is a place holder created earlier by addPsuedoAlignment.R\n\tpseudoreadscnt <- length(grep(\"pseudoreads\", names(alignGR)))\n\t\n\tif(pseudoreadscnt > 0 || length(alignGR) < minReadCount ) {\n\t\t\n\t\twarning(sprintf(\"Not enough (< %d) alignment found in this chromosome:\",\n\t\t\t\t\t\tminReadCount))\n\t\t\t\t\n\t\tif(is.null(binSize) || floor(seqlengths(alignGR)[chrname]/binSize) < backupNumBins) {\t\n\t\t\t\n\t\t\tbinSize <- floor(seqlengths(alignGR)[chrname]/backupNumBins)\n\t\t\t\n\t\t\twarning(sprintf(\"binSize has been arbitrarily set to %d (i.e. 1/%d of the total %s length\",\n\t\t\t\t\t\t\tbinSize, backupNumBins, seqlengths(alignGR)[chrname], chrname))\t\t\t\n\t\t}\t\t\t\t\t\t\t\t\n\t\t\n\t\tnbhGR <- addDummyProb(alignGR, K=K, binSize, randomProb=FALSE, runViterbi=list(...)$runViterbi)\n\t\t\n\t\treturn(nbhGR)\n\t}\n\t\n\t\t\n\t# finally if binSize is null, then use binSize selection\n\tif(is.null(binSize)) {\n\t\n\t\tmessage(sprintf(\"***0. Computing optimal bin size.\"))\n\t\t\t\t\t\t\t\t\t\t\n\t\tb <- selectBinSize(alignGR, minBinSize=minBinSize, maxBinSize = maxBinSize, increment=increment,\n\t\t\t\tgetFullResults=!missing(pathToSavePlotsOfBinSizesVersusCosts))\n\t\t\n\t\tif(!missing(pathToSavePlotsOfBinSizesVersusCosts) && is.list(b)) {\n\t\t\tbinSize <- b$bestBinSize\n\t\t\t\n\t\t\t# plot costs as a function of bin sizes \n\t\t\tpdf(file=sprintf(\"%s%s.pdf\", pathToSavePlotsOfBinSizesVersusCosts, chrname))\t\t\n\t\t\t\tchrlen <- seqlengths(alignGR)[chrname]\n\t\t\t\tplot(b$binSizes, b$costs)\n\t\t\t\tlegend(\"topright\", box.lty=0,\n\t\t\t\t\t\tsprintf(\"%s: 1-%d;\\nTotal mapped reads: %d;\\nOptimal bin size = %d bp\",\n\t\t\t\t\t\t\t\tchrname, chrlen, length(alignGR), binSize))\n\t\t\tdev.off()\n\t\t\t\n\t\t} else {\n\t\t\tbinSize <- b\n\t\t}\t\t\t\t\n\t\t\n\t\tmessage(sprintf(\"\\nOptimal bin size: %d bp\\n\", binSize))\n\t}\n\t\n\t\n\t# if binsize is initiallly undefined and is determined to be too large \n\t# s.t. there are fewer than backupNumBins (default: 10)\n\t# then set the bin size to a smaller size to ensure backupNumBins of bins\n\tif(floor(seqlengths(alignGR)[chrname]/binSize) < backupNumBins) \t{\n\t\t\n\t\toldBinSize <- binSize\n\t\t\n\t\tbinSize <- floor(seqlengths(alignGR)[chrname]/backupNumBins)\t\t\n\t\t\n\t\twarning(sprintf(\"binSize %d is too large for %s (%d).\\nAnd change binSize to %d (i.e. 1/%d of the total chromosome length\",\n\t\t\t\t\t\toldBinSize, chrname, seqlengths(alignGR)[chrname], binSize, backupNumBins)\n\t\t)\n\t\t\n\t\tmessage(sprintf(\"\\nBin size has been reset to: %d bp\\n\", binSize))\t\t\t\t\n\t}\n\t\n\t\n\t# Compute Coverage within bins and run HMM (nbh) on bin count vector\n\tmessage(sprintf(\"***1. Traning NB HMM to derive posterior (and Viterbi state sequence:)\"))\n\t\t\n\n\tif(verbose) nbhGR <- nbh(binCount(alignGR, binSize=binSize), K=K, ...)\n\tif(!verbose) suppressMessages(nbhGR <- nbh(binCount(alignGR, binSize=binSize), K=K, ...))\n\t\n\t\t\n\tif(class(nbhGR) != \"GRanges\" && allowSecondAttempt && !useDefinedBinSize) {\n\t\t\n\t\ti <- 1\n\t\t\n\t\twarning(sprintf(\"Main function resulted in None GRanges object on %s.\\nThis might be due to bin size. Attempting with different best bin sizes.\"), chrname)\n\t\t\n\t\tb <- selectBinSize(alignGR, minBinSize=minBinSize, maxBinSize = maxBinSize, \n\t\t\t\tincrement=increment, getFullResults = TRUE)\n\t\t\n\t\twhile(class(nbhGR) != \"GRanges\") {\n\t\t\tbinSize <- b$binSizes[order(b$cost)[i]]\n\t\t\t\n\t\t\t# Compute Coverage within bins and run HMM (nbh) on bin count vector\n\t\t\tif(verbose) nbhGR <- nbh(binCount(alignGR, binSize=binSize), K=K, ...)\n\t\t\tif(!verbose) suppressMessages(nbhGR <- nbh(binCount(alignGR, binSize=binSize), K=K, ...))\n\t\t\t\n\t\t\ti <- i + 1\n\t\t}\n\t}\n\t\t\n\t# if all bets are off, then use dummy value with uniform posterior \n\tif(class(nbhGR) != \"GRanges\")\n\t{\n\t\twarning(\"HMM failed on this chromosome (after trying all bin sizes). Default uniform posterior is used instead\")\n\t\t\n\t\tnbhGR <- addDummyProb(alignGR, K=K, binSize, randomProb=FALSE, runViterbi=list(...)$runViterbi)\t\t\t\n\t}\n\t\n\t\t\t\t\t\t\t\n\treturn(nbhGR)\t\t\n}",
    "created" : 1440348236615.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3317408648",
    "id" : "4D8A158E",
    "lastKnownWriteTime" : 1401316564,
    "last_content_update" : 0,
    "path" : "~/myBiocPkg/RIPSeeker/R/mainSeekSingleChrom.R",
    "project_path" : "mainSeekSingleChrom.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}